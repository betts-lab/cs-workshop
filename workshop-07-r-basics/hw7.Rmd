---
title: "workshop-07-hw"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Welcome to Workshop-07-hw
Your homework today will be to read in two CSV files and manipulate the data frame to get the data in different forms and to do some preliminary statistical analysis on this file. You DO NOT need to load any additional libraries for this homework. Any usage of `library(pkg_name)` is disallowed for this assignment - i.e. no tidyverse libraries.

## Step 1
Create a chunk here and do the following:

1. Read in the `forHwFile1.csv` and set it to a variable called `dfFile1`.
2. Read in the `forHwFile2.csv` and set it to a variable called `dfFile2`.
3. Print out these two variables.
4. Print out their dimensions (i.e. the number of rows and the number of columns).
5. Write a logical statement to check if the `sample` column in `dfFile1` matches the `sample` column in `dfFile2`. Your statement should return a single logical value, not a vector of logical values.  

```{r}
dfFile1 <- read.csv("forHwFile1.csv")
dfFile2 <- read.csv("forHwFile2.csv")

dfFile1
dfFile2

dim(dfFile1)
dim(dfFile2)

dfFile1$sample == dfFile2$sample
```

## Step 2
What can you tell about their dimensions and what's in the dataset? It looks like someone accidentally split the dataset into two separate files since the `sample` column are the same. Let's combine them to make one giant data frame.

Create a new chunk. Create a new variable called `dfCompiled` that combines the two data frames from Step 1. Because the `sample` column is the same between the two original data frames, we don't want to keep a duplicate column. Your final `dfCompiled` should not contain duplicate `sample` columns.

Print out `dfCompiled`.

```{r}
dfCompiled <- cbind(dfFile1, dfFile2[, 2:ncol(dfFile2)])

dfCompiled
```


## Step 3
Perfect! We've got a compiled data frame. Let's do some preliminary analysis.

1. Create a named vector where each name corresponds to the column name and the value corresponds to the mean of the column. Because `sample` column contains type character, this column should not be included in this vector.
2. Create another named vector, similar to done in the previous step, where the value corresponds to the standard deviation of the column. Use your vector from the previous step to assist with this.
3. Try out the `summary()` function on a random column and print out the result. Describe what you see in Markdown.
4. Try out the `summary()` function on `dfCompiled` and print out the result. Describe what you see in Markdown.

Put your description for 3 and 4 below:

```{r}
meanV <- colMeans(dfCompiled[, 2:ncol(dfCompiled)])
sdV <- c()

for (j in c(2:ncol(dfCompiled))) {
  col <- dfCompiled[, j]
  col <- sum(col - meanV[colnames(dfCompiled)[j]]) ** 2
  colSd <- col / length(col)
  sdV <- append(sdV, colSd)
}

names(sdV) <- names(meanV)

summary(dfCompiled$CD3)
summary(dfCompiled)
```


## Step 4
Let's practice some indexing.

1. Print out the even numbered rows in the data frame.
2. Print out the odd numbered columns in the data frame.
3. Print out the even numbered rows AND odd numbered columns in the data frame.
4. Print out the subset (i.e. all columns and only the rows matching the condition) of the data frame where the `CD3` column is >= 25.
5. Print out the subset (i.e. all columns and only the rows matching the condition) of the data frame where the `CD4` column is < 15 and `CD8` column is > 30.

6. Add a new column to `dfCompiled` called `goingWild` with a vector of numbers of your choice. If you don't want to come up with numbers, you can look up the `runif` function that can generate a vector of random numbers.

```{r}
# 1
dfCompiled[seq(2,nrow(dfCompiled), 2), ]

# 2
dfCompiled[, seq(1,ncol(dfCompiled), 2)]

# 3 
dfCompiled[seq(2, nrow(dfCompiled), 2), seq(1, ncol(dfCompiled), 2)]

# 4
dfCompiled[dfCompiled$CD3 >= 25, ]

#5 
dfCompiled[dfCompiled$CD4 < 15 & dfCompiled$CD8 > 30, ]

#6
dfCompiled$goingWild <- runif(nrow(dfCompiled), 3, 5)
```


## Step 5
Let's practice making some functions now.

1. Write a function called `filterDataFrame` that takes three arguments: `df`, `colname`, and `value`. This function will take a data frame (`df`) and filter out the rows where the `colname` is not equal to `value`. You should check and stop the function early if `colname` is not actually a column name in `df`.

You should try out this function on different column names and values to ensure that it works. 

```{r}
filterDataFrame <- function(df, colname, value) {
  stopifnot(colname %in% colnames(df))
  
  return(df[df[, colname] == value, ])
}

filterDataFrame(dfCompiled, "goingWild", dfCompiled$goingWild[1])
filterDataFrame(dfCompiled, "goingWild", 0)
```


## Step 6
Let's practice our for loops, sapply, and lapply.
1. Using a for loop, create a new column to `dfCompiled` that adds together `CD4` and `CD8` for every even numbered row. For odd number rows, give it a value of -1.
2. Using sapply, create a new column to `dfCompiled` that adds together `CD4` and `CD8` for every even numbered row. For odd number rows, give it a value of -1.
```{r}
# 1
tmpCol <- rep(-1, nrow(dfCompiled))
for (i in seq(1, nrow(dfCompiled), 2)) {
  tmpCol[i] <- dfCompiled[i, "CD4"] + dfCompiled[i, "CD8"]
}
dfCompiled$newColumn1 <- tmpCol


# 2
dfCompiled$newColumn2 <- sapply(c(1:nrow(dfCompiled)), function(i) {
  if (i %% 2) {
    return(dfCompiled[i, "CD4"] + dfCompiled[i, "CD8"])
  } else {
    return(-1)
  }
})
```


